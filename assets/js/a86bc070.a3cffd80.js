"use strict";(self.webpackChunklcc=self.webpackChunklcc||[]).push([[2332],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return d}});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=r.createContext({}),s=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},p=function(e){var n=s(e.components);return r.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),m=s(t),d=i,f=m["".concat(l,".").concat(d)]||m[d]||u[d]||o;return t?r.createElement(f,a(a({ref:n},p),{},{components:t})):r.createElement(f,a({ref:n},p))}));function d(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,a=new Array(o);a[0]=m;var c={};for(var l in n)hasOwnProperty.call(n,l)&&(c[l]=n[l]);c.originalType=e,c.mdxType="string"==typeof e?e:i,a[1]=c;for(var s=2;s<o;s++)a[s]=t[s];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},5993:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return c},contentTitle:function(){return l},metadata:function(){return s},toc:function(){return p},default:function(){return m}});var r=t(7462),i=t(3366),o=(t(7294),t(3905)),a=["components"],c={sidebar_position:1,tags:["graph","inoi","floyd-warshall-algorithm","2014"]},l="Free ticket, INOI 2014",s={unversionedId:"inoi/inoi1402",id:"inoi/inoi1402",title:"Free ticket, INOI 2014",description:"Problem Description",source:"@site/code/inoi/inoi1402.md",sourceDirName:"inoi",slug:"/inoi/inoi1402",permalink:"/lcc/code/inoi/inoi1402",editUrl:"https://github.com/trayimurti/lcc/tree/main/code/inoi/inoi1402.md",tags:[{label:"graph",permalink:"/lcc/code/tags/graph"},{label:"inoi",permalink:"/lcc/code/tags/inoi"},{label:"floyd-warshall-algorithm",permalink:"/lcc/code/tags/floyd-warshall-algorithm"},{label:"2014",permalink:"/lcc/code/tags/2014"}],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,tags:["graph","inoi","floyd-warshall-algorithm","2014"]},sidebar:"tutorialSidebar",previous:{title:"Code",permalink:"/lcc/code/intro"}},p=[{value:"Problem Description",id:"problem-description",children:[],level:2},{value:"Prerequisites",id:"prerequisites",children:[],level:2},{value:"Solution",id:"solution",children:[],level:2},{value:"Code",id:"code",children:[],level:2}],u={toc:p};function m(e){var n=e.components,t=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"free-ticket-inoi-2014"},"Free ticket, INOI 2014"),(0,o.kt)("h2",{id:"problem-description"},"Problem Description"),(0,o.kt)("p",null,"Question : ",(0,o.kt)("a",{parentName:"p",href:"https://www.codechef.com/INOIPRAC/problems/INOI1402"},"Free Ticket, INOI 2014")," "),(0,o.kt)("p",null,"Submit Code : ",(0,o.kt)("a",{parentName:"p",href:"https://www.codechef.com/INOIPRAC/submit/INOI1402"},"Codechef")),(0,o.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://trayimurti.github.io/lcc/docs/graph-algorithms/shortest-paths/floyd-warshall"},"Floyd-Warshall Algorithm")),(0,o.kt)("h2",{id:"solution"},"Solution"),(0,o.kt)("p",null,"Nikhil has to choose two stations whose minimum flight price is maximum in every possible station pairs that can be chosen. So, First, we will find minimum price between every two stations and then take maximum among those which will be our answer."),(0,o.kt)("p",null,"It is straight forward problem of Floyd-Warshall Algorithm (The Shortest Path), just nodes have been replaced with stations and distances with price of flights."),(0,o.kt)("h2",{id:"code"},"Code"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1000000000\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n    int price[n+1][n+1];\n    int x, y, p;\n\n    for(int i=0;i<=n;i++)\n        for(int j=0;j<=n;j++)\n            price[i][j] = INF;\n    \n    for(int i=0;i<m;i++){\n        cin >> x >> y >> p;\n        price[x][y] = p;\n        price[y][x] = p;\n    }\n    \n    for(int k=1;k<=n;k++)\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++)\n                price[i][j] = min(price[i][j], price[i][k] + price[k][j]);\n    \n    int ans = 0;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if(i != j)\n                ans = max(ans, price[i][j]);\n    \n    cout << ans;\n\n    return 0;\n}\n")))}m.isMDXComponent=!0}}]);