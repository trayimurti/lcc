"use strict";(self.webpackChunklcc=self.webpackChunklcc||[]).push([[7072],{3905:function(e,t,a){a.d(t,{Zo:function(){return l},kt:function(){return d}});var n=a(7294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var m=n.createContext({}),p=function(e){var t=n.useContext(m),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},l=function(e){var t=p(e.components);return n.createElement(m.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,r=e.originalType,m=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),c=p(a),d=s,g=c["".concat(m,".").concat(d)]||c[d]||h[d]||r;return a?n.createElement(g,i(i({ref:t},l),{},{components:a})):n.createElement(g,i({ref:t},l))}));function d(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=a.length,i=new Array(r);i[0]=c;var o={};for(var m in t)hasOwnProperty.call(t,m)&&(o[m]=t[m]);o.originalType=e,o.mdxType="string"==typeof e?e:s,i[1]=o;for(var p=2;p<r;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},8051:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return o},contentTitle:function(){return m},metadata:function(){return p},toc:function(){return l},default:function(){return c}});var n=a(7462),s=a(3366),r=(a(7294),a(3905)),i=["components"],o={sidebar_position:4,tags:["graph","shortest-paths","dijkstra-algorithm"]},m="Dijkstra's Algorithm",p={unversionedId:"graph-algorithms/shortest-paths/dijkstra",id:"graph-algorithms/shortest-paths/dijkstra",title:"Dijkstra's Algorithm",description:"Dijkstra\u2019s algorithm finds shortest paths from the starting node to all nodes of the graph, like the Bellman\u2013Ford algorithm. The benefit of Dijkstra\u2019s algorithm is that it is more efficient and can be used for processing large graphs. However, the algorithm requires that there are no negative weight edges in the graph.",source:"@site/docs/graph-algorithms/shortest-paths/dijkstra.md",sourceDirName:"graph-algorithms/shortest-paths",slug:"/graph-algorithms/shortest-paths/dijkstra",permalink:"/lcc/docs/graph-algorithms/shortest-paths/dijkstra",editUrl:"https://github.com/trayimurti/lcc/tree/main/docs/graph-algorithms/shortest-paths/dijkstra.md",tags:[{label:"graph",permalink:"/lcc/docs/tags/graph"},{label:"shortest-paths",permalink:"/lcc/docs/tags/shortest-paths"},{label:"dijkstra-algorithm",permalink:"/lcc/docs/tags/dijkstra-algorithm"}],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,tags:["graph","shortest-paths","dijkstra-algorithm"]},sidebar:"tutorialSidebar",previous:{title:"Shortest Path Faster Algorithm (SPFA)",permalink:"/lcc/docs/graph-algorithms/shortest-paths/spfa"},next:{title:"Floyd-Warshall Algorithm",permalink:"/lcc/docs/graph-algorithms/shortest-paths/floyd-warshall"}},l=[{value:"Algorithm",id:"algorithm",children:[],level:2},{value:"Implementation",id:"implementation",children:[],level:2},{value:"Negative Edges",id:"negative-edges",children:[],level:2}],h={toc:l};function c(e){var t=e.components,o=(0,s.Z)(e,i);return(0,r.kt)("wrapper",(0,n.Z)({},h,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"dijkstras-algorithm"},"Dijkstra's Algorithm"),(0,r.kt)("p",null,"Dijkstra\u2019s algorithm finds shortest paths from the starting node to all nodes of the graph, like the Bellman\u2013Ford algorithm. The benefit of Dijkstra\u2019s algorithm is that it is more efficient and can be used for processing large graphs. However, the algorithm requires that there are no negative weight edges in the graph."),(0,r.kt)("h2",{id:"algorithm"},"Algorithm"),(0,r.kt)("p",null,"Like the Bellman\u2013Ford algorithm, Dijkstra\u2019s algorithm maintains distances to the nodes and reduces them during the search. At each step, Dijkstra\u2019s algorithm selects a node that has not been processed yet and whose distance is as small as possible. Then, the algorithm goes through all edges that start at the node and reduces the distances using them. Dijkstra\u2019s algorithm is efficient, because it only processes each edge in the graph once, using the fact that there are no negative edges."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"center"},(0,r.kt)("img",{alt:"Dijkstra&#39;s Algorithm",src:a(628).Z,width:"250",height:"250"})))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},(0,r.kt)("strong",{parentName:"td"},"Fig. 20:")," Dijkstra's Algorithm")))),(0,r.kt)("p",null,"Fig. 20 shows how Dijkstra\u2019s algorithm processes a graph. Like in the Bellman\u2013Ford algorithm, the initial distance to all nodes, except for the starting node, is infinite. The algorithm processes the nodes in the order 1, 5, 4, 2, 3, and at each node reduces distances using edges that start at the node. Note that the distance to a node never changes after processing the node."),(0,r.kt)("h2",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,"An efficient implementation of Dijkstra\u2019s algorithm requires that we can efficiently find the minimum-distance node that has not been processed. An appropriate data structure for this is a priority queue that contains the remaining nodes ordered by their distances. Using a priority queue, the next node to be processed can be retrieved in logarithmic time."),(0,r.kt)("p",null,"A typical textbook implementation of Dijkstra\u2019s algorithm uses a priority queue that has an operation for modifying a value in the queue. This allows us to have a single instance of each node in the queue and update its distance when needed. However, standard library priority queues do not provide such an operation, and a somewhat different implementation is usually used in competitive programming."),(0,r.kt)("p",null,"The idea is to add a new instance of a node to the priority queue always when its distance changes."),(0,r.kt)("p",null,"Our implementation of Dijkstra\u2019s algorithm calculates the minimum distances from a node ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," to all other nodes of the graph. The graph is stored as adjacency lists so that ",(0,r.kt)("inlineCode",{parentName:"p"},"adj[a]")," contains a pair ",(0,r.kt)("inlineCode",{parentName:"p"},"(b, w)")," always when there is an edge from node a to node ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," with weight ",(0,r.kt)("inlineCode",{parentName:"p"},"w"),". The priority queue ",(0,r.kt)("inlineCode",{parentName:"p"},"priority_queue<pair<int,int>> q;")," contains pairs of the form ",(0,r.kt)("inlineCode",{parentName:"p"},"(\u2212d, x)"),", meaning that the current distance to node ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"d"),"."),(0,r.kt)("p",null,"The array distance contains the distance to each node, and the array processed indicates whether a node has been processed."),(0,r.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"NOTE")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("ol",{parentName:"div"},(0,r.kt)("li",{parentName:"ol"},"The priority queue contains negative distances to nodes. The reason for this is that the default version of the C++ priority queue finds maximum elements, while we want to find minimum elements."),(0,r.kt)("li",{parentName:"ol"},"While there may be several instances of a node in the priority queue, only the instance with the minimum distance will be processed.")))),(0,r.kt)("p",null,"The implementation is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"for (int i = 1; i <= n; i++) {\n    distance[i] = INF;\n}\ndistance[x] = 0;\nq.push({0,x});\nwhile (!q.empty()) {\n    int a = q.top().second; q.pop();\n    if (processed[a]) continue;\n    processed[a] = true;\n    for (auto u : adj[a]) {\n        int b = u.first, w = u.second;\n        if (distance[a]+w < distance[b]) {\n            distance[b] = distance[a]+w;\n            q.push({-distance[b],b});\n        }\n    }\n}\n")),(0,r.kt)("h2",{id:"negative-edges"},"Negative Edges"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"center"},(0,r.kt)("img",{alt:"A graph where Dijkstra&#39;s algorithm fails",src:a(6726).Z,width:"320",height:"186"})))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},(0,r.kt)("strong",{parentName:"td"},"Fig. 21:")," A graph where Dijkstra's algorithm fails")))),(0,r.kt)("p",null,"The efficiency of Dijkstra\u2019s algorithm is based on the fact that the graph does not have negative edges. However, if the graph has a negative edge, the algorithm may give incorrect results. As an example, consider the graph in Fig. 21."),(0,r.kt)("p",null,"The shortest path from node 1 to node 4 is ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mn",{parentName:"mrow"},"1"),(0,r.kt)("mo",{parentName:"mrow"},"\u2192"),(0,r.kt)("mn",{parentName:"mrow"},"3"),(0,r.kt)("mo",{parentName:"mrow"},"\u2192"),(0,r.kt)("mn",{parentName:"mrow"},"4")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"1 \\to 3 \\to 4")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},"1"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"\u2192"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},"3"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"\u2192"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},"4")))))," and its length is 1. However, Dijkstra\u2019s algorithm incorrectly finds the path ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mn",{parentName:"mrow"},"1"),(0,r.kt)("mo",{parentName:"mrow"},"\u2192"),(0,r.kt)("mn",{parentName:"mrow"},"2"),(0,r.kt)("mo",{parentName:"mrow"},"\u2192"),(0,r.kt)("mn",{parentName:"mrow"},"4")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"1 \\to 2 \\to 4")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},"1"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"\u2192"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},"2"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,r.kt)("span",{parentName:"span",className:"mrel"},"\u2192"),(0,r.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,r.kt)("span",{parentName:"span",className:"mord"},"4")))))," by greedily following minimum weight edges."))}c.isMDXComponent=!0},628:function(e,t,a){t.Z=a.p+"assets/images/20-1714122d5464f80645593c4ba3863104.gif"},6726:function(e,t,a){t.Z=a.p+"assets/images/21-19e415de07759d56d273247817a0749f.png"}}]);