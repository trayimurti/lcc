"use strict";(self.webpackChunklcc=self.webpackChunklcc||[]).push([[9335],{3905:function(e,a,t){t.d(a,{Zo:function(){return l},kt:function(){return d}});var n=t(7294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function s(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function p(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?s(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function m(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=n.createContext({}),o=function(e){var a=n.useContext(i),t=a;return e&&(t="function"==typeof e?e(a):p(p({},a),e)),t},l=function(e){var a=o(e.components);return n.createElement(i.Provider,{value:a},e.children)},c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},h=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,l=m(e,["components","mdxType","originalType","parentName"]),h=o(t),d=r,g=h["".concat(i,".").concat(d)]||h[d]||c[d]||s;return t?n.createElement(g,p(p({ref:a},l),{},{components:t})):n.createElement(g,p({ref:a},l))}));function d(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var s=t.length,p=new Array(s);p[0]=h;var m={};for(var i in a)hasOwnProperty.call(a,i)&&(m[i]=a[i]);m.originalType=e,m.mdxType="string"==typeof e?e:r,p[1]=m;for(var o=2;o<s;o++)p[o]=t[o];return n.createElement.apply(null,p)}return n.createElement.apply(null,t)}h.displayName="MDXCreateElement"},8708:function(e,a,t){t.r(a),t.d(a,{frontMatter:function(){return m},contentTitle:function(){return i},metadata:function(){return o},toc:function(){return l},default:function(){return h}});var n=t(7462),r=t(3366),s=(t(7294),t(3905)),p=["components"],m={sidebar_position:1,tags:["graph","graph-traversal","dfs"]},i="Depth-First Search (DFS)",o={unversionedId:"graph-algorithms/graph-traversal/dfs",id:"graph-algorithms/graph-traversal/dfs",title:"Depth-First Search (DFS)",description:"Depth-first search (DFS) is a straightforward graph traversal technique. The algorithm begins at a starting node and proceeds to all other nodes that are reachable from the starting node using the edges of the graph.",source:"@site/docs/graph-algorithms/graph-traversal/dfs.md",sourceDirName:"graph-algorithms/graph-traversal",slug:"/graph-algorithms/graph-traversal/dfs",permalink:"/lcc/docs/graph-algorithms/graph-traversal/dfs",editUrl:"https://github.com/trayimurti/lcc/tree/main/docs/graph-algorithms/graph-traversal/dfs.md",tags:[{label:"graph",permalink:"/lcc/docs/tags/graph"},{label:"graph-traversal",permalink:"/lcc/docs/tags/graph-traversal"},{label:"dfs",permalink:"/lcc/docs/tags/dfs"}],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,tags:["graph","graph-traversal","dfs"]},sidebar:"tutorialSidebar",previous:{title:"Graph Representation",permalink:"/lcc/docs/graph-algorithms/graph-basics/graph-representation"}},l=[{value:"Algorithm",id:"algorithm",children:[],level:2},{value:"Implementation",id:"implementation",children:[],level:2}],c={toc:l};function h(e){var a=e.components,m=(0,r.Z)(e,p);return(0,s.kt)("wrapper",(0,n.Z)({},c,m,{components:a,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"depth-first-search-dfs"},"Depth-First Search (DFS)"),(0,s.kt)("p",null,"Depth-first search (DFS) is a straightforward graph traversal technique. The algorithm begins at a starting node and proceeds to all other nodes that are reachable from the starting node using the edges of the graph."),(0,s.kt)("h2",{id:"algorithm"},"Algorithm"),(0,s.kt)("p",null,"Depth-first search always follows a single path in the graph as long as it finds new nodes. After this, it returns to previous nodes and begins to explore other parts of the graph. The algorithm keeps track of visited nodes, so that it processes each node only once."),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"center"},(0,s.kt)("img",{alt:"Depth-First Search",src:t(7628).Z,width:"200",height:"200"})))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"center"},(0,s.kt)("strong",{parentName:"td"},"Fig. 13:")," Depth-First Search")))),(0,s.kt)("p",null,"Fig. 13 shows how depth-first search processes a graph. The search can begin at any node of the graph; in this example we begin the search at node 1. First the search explores the path ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mn",{parentName:"mrow"},"1"),(0,s.kt)("mo",{parentName:"mrow"},"\u2192"),(0,s.kt)("mn",{parentName:"mrow"},"2"),(0,s.kt)("mo",{parentName:"mrow"},"\u2192"),(0,s.kt)("mn",{parentName:"mrow"},"3"),(0,s.kt)("mo",{parentName:"mrow"},"\u2192"),(0,s.kt)("mn",{parentName:"mrow"},"5")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"1 \\to 2 \\to 3 \\to 5")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"1"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.kt)("span",{parentName:"span",className:"mrel"},"\u2192"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"2"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.kt)("span",{parentName:"span",className:"mrel"},"\u2192"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"3"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,s.kt)("span",{parentName:"span",className:"mrel"},"\u2192"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"5"))))),", then returns back to node 1 and visits the remaining node 4."),(0,s.kt)("h2",{id:"implementation"},"Implementation"),(0,s.kt)("p",null,"Depth-first search can be conveniently implemented using recursion. The following function dfs begins a depth-first search at a given node. The function assumes that the graph is stored as adjacency lists in an array (",(0,s.kt)("inlineCode",{parentName:"p"},"vector<int> adj[N];"),") and also maintains an array that keeps track of the visited nodes (",(0,s.kt)("inlineCode",{parentName:"p"},"bool visited[N];"),"). Initially, each array value is ",(0,s.kt)("inlineCode",{parentName:"p"},"false"),", and when the search arrives at node ",(0,s.kt)("inlineCode",{parentName:"p"},"s"),", the value of ",(0,s.kt)("inlineCode",{parentName:"p"},"visited[s]")," becomes ",(0,s.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,s.kt)("p",null,"The function can be implemented as follows:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"void dfs(int s) {\n    if (visited[s]) return;\n    visited[s] = true;\n    // process node s\n    for (auto u: adj[s]) {\n        dfs(u);\n    }\n}\n")),(0,s.kt)("p",null,"The time complexity of depth-first search is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow",mathvariant:"script"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mi",{parentName:"mrow",mathvariant:"script"},"n"),(0,s.kt)("mo",{parentName:"mrow"},"+"),(0,s.kt)("mi",{parentName:"mrow",mathvariant:"script"},"m"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\cal{O}(n +m)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord"},(0,s.kt)("span",{parentName:"span",className:"mord mathcal",style:{marginRight:"0.02778em"}},"O")),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.kt)("span",{parentName:"span",className:"mbin"},"+"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal"},"m"),(0,s.kt)("span",{parentName:"span",className:"mclose"},")"))))))," where ",(0,s.kt)("inlineCode",{parentName:"p"},"n")," is the number of nodes and ",(0,s.kt)("inlineCode",{parentName:"p"},"m")," is the number of edges, because the algorithm processes each node and edge once."))}h.isMDXComponent=!0},7628:function(e,a,t){a.Z=t.p+"assets/images/13-83f415d5912a5e2ffa6d75a38e6e1367.gif"}}]);