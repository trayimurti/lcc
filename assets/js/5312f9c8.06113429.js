"use strict";(self.webpackChunklcc=self.webpackChunklcc||[]).push([[314],{3690:function(n){n.exports=JSON.parse('{"blogPosts":[{"id":"ioitc-day-1-part-3","metadata":{"permalink":"/lcc/blog/ioitc-day-1-part-3","editUrl":"https://github.com/trayimurti/lcc/blog/2022-01-25-ioitc-day-1-part-3/index.md","source":"@site/blog/2022-01-25-ioitc-day-1-part-3/index.md","title":"IOITC Day-1 Part-3","description":"Let\'s increase problem level further.","date":"2022-01-25T00:00:00.000Z","formattedDate":"January 25, 2022","tags":[{"label":"ioitc","permalink":"/lcc/blog/tags/ioitc"},{"label":"ioi","permalink":"/lcc/blog/tags/ioi"},{"label":"sliding-window-algorithm","permalink":"/lcc/blog/tags/sliding-window-algorithm"},{"label":"day-1","permalink":"/lcc/blog/tags/day-1"},{"label":"part-3","permalink":"/lcc/blog/tags/part-3"},{"label":"garden","permalink":"/lcc/blog/tags/garden"}],"readingTime":4.74,"truncated":true,"authors":[{"name":"Trayi Murti","title":"IOI Training Camp Participant","url":"https://github.com/trayimurti","imageURL":"https://github.com/trayimurti.png","key":"trayimurti"}],"frontMatter":{"slug":"ioitc-day-1-part-3","title":"IOITC Day-1 Part-3","authors":"trayimurti","tags":["ioitc","ioi","sliding-window-algorithm","day-1","part-3","garden"]},"nextItem":{"title":"IOITC Day-1 Part-2","permalink":"/lcc/blog/ioitc-day-1-part-2"}},"content":"Let\'s increase problem level further.\\n\\n### Problem\\n\\nGiven a grid of integers **L = [[A<sub>1,1</sub>, A<sub>1,2</sub>, A<sub>1,3</sub>, ..., A<sub>1,M</sub>], [A<sub>2,1</sub>, A<sub>2,1</sub>, A<sub>2,3</sub>, ..., A<sub>2,M</sub>], [A<sub>3,1</sub>, A<sub>3,2</sub>, A<sub>3,3</sub>, ..., A<sub>3,M</sub>], [..., ..., ..., ..., ...], [A<sub>N,1</sub>, A<sub>N,2</sub>, A<sub>N,3</sub>, ..., A<sub>N,M</sub>]]**. Where **A<sub>i,j</sub> \u2265 0**, **0 \u2264 i \u2264 N**, **0 \u2264 j \u2264 M**. You have to find the least perimeter of rectangle which adds up to a given integer **K**.\\n\\n\x3c!--truncate--\x3e\\n\\nFor example, \\nIf  **L = [[1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 0, 1, 1, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 2], [1, 0, 0, 0, 0]]** and **K = 3**, the answer would be **22**, rectangles will be **{(2, 3), (4, 4)}**.\\n\\n![Rectangle Solution](./ioitc_day1_img_1.png)\\n\\n### Solution\\n\\nThe first approach that comes to mind is calculating 2D prefix sum, and then finding the least perimeter rectangular field adding up to **K**.\\nCalculating 2D prefix sum will take $\\\\cal{O}(N \\\\cdot M)$ time. But, if we find rectangle adding up to **K** by taking every possible rectangle then it will take $\\\\cal{O}(X)$ time, where **X = Number of possible rectangles**. Let\'s calculate **X**. We will choose two indices of length, and two vertices of width, which will form a rectangle. Number of ways to choose two indices of length is $N \\\\choose 2$ and of width is $M \\\\choose 2$.\\n\\n$$\\nX = {N \\\\choose 2} \\\\cdot {M \\\\choose 2}\\n$$\\n$$\\n= \\\\frac{N\\\\cdot(N+1)}{2} \\\\cdot \\\\frac{M\\\\cdot(M+1)}{2}\\n$$\\n$$\\n= \\\\frac{(N^2 + N)\\\\cdot(M^2 + M)}{4}\\n$$  \\n\\n$$\\nX = \\\\frac{N^2 \\\\cdot M^2+N^2 \\\\cdot M+M^2 \\\\cdot N+M \\\\cdot N}{4}\\n$$\\n\\nWe can see that overall time complexity is $\\\\cal{O}(N^2 \\\\cdot M^2).$ Can we optimize it? ... Yes, by using sliding window algorithm on 2D array. But, how we will apply sliding window algorithm on a 2D array?\\n\\nFor using sliding window algorithm, we have chosen two indices from either row or column as shown below and apply sliding window with fixed row or column. \\n\\n![Fix row and column](./ioitc_day1_img_2.png)\\n\\nUsing sliding window for a fixed rows or columns will take $\\\\cal{O}(N)$ or $\\\\cal{O}(M)$ time complexity accordingly. As we have to repeat it for others fixed rows or columns also. Which will result in $\\\\cal{O}(N \\\\cdot M^2)$ or $\\\\cal{O}(M \\\\cdot N^2)$ time complexity.\\n\\n![Sliding Window GIF](./ioitc_day1_img_3.gif)\\n\\n### Code\\n\\n```cpp\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n#define INF INT_MAX\\n\\npair<int,int> ans[2];\\n\\nvoid slidingWindow(vector<vector<int>>& l, int n, int m, int k){\\n    int st = -1,en = -1,perimeter = INF;\\n    vector<vector<int>> prefixL(n+1,vector<int>(m+1));\\n    for(int i=0;i<=n;i++)   prefixL[i][0] = 0;\\n    for(int j=0;j<=m;j++)   prefixL[0][j] = 0;\\n    for(int i=1;i<=n;i++)\\n        for(int j=1;j<=m;j++)\\n            prefixL[i][j] = (l[i-1][j-1] + prefixL[i-1][j] + prefixL[i][j-1] - prefixL[i-1][j-1]);\\n    for(int i=0;i<n;i++){\\n        for(int j=i;j<n;j++){\\n            st = 0;en = 0;\\n            int cnt = prefixL[j+1][1] - prefixL[j+1][0] - prefixL[i][1] + prefixL[i][0];\\n            for(;k<m;){\\n                if(cnt > k){\\n                    if(st == en){   st++;en++;}\\n                    else            st++;\\n                }else if(cnt < k){\\n                    en++;\\n                }else{\\n                    while(prefixL[j+1][st+1] - prefixL[j+1][st] - prefixL[i][st+1] + prefixL[i][st] == 0)\\n                        st++;\\n                    if(perimeter > 2*((j-i+1)+(en-st+1))){\\n                        perimeter = 2*((j-i+1)+(en-st+1));\\n                        ans[0].first = i;ans[0].second = st;\\n                        ans[1].first = j;ans[0].second = en;\\n                    }\\n                    en++;\\n                }\\n                if(en == m) break;\\n                cnt = prefixL[j+1][en+1] - prefixL[j+1][st] - prefixL[i][en+1] + prefixL[i][st];\\n            }\\n        }\\n    }\\n}\\n\\nint main() {\\n    int n,m,k;\\n    cin >> n >> m >> k;\\n    vector<vector<int>> l(n,vector<int>(m));\\n    for(int i=0;i<n;i++)\\n        for(int j=0;j<m;j++)\\n            cin >> l[i][j];\\n    slidingWindow(l,n,m,k);\\n    cout << ans[0].first << \\" \\" << ans[0].second << endl\\n         << ans[1].first << \\" \\" << ans[1].second;\\n}\\n```\\n\\n## Problem : IOI, Garden, 2005\\n\\n### Question summary:\\n\\nA rose garden in rectangular form is **l** meters long and **w** meters wide. We have to fence two rectangular fences inside the garden such that both are disjoint and the sum of their perimeter is minimal. So, we have to just output the sum of perimeter of those rectangles.\\n\\n### Solution\\n\\nWe will divide the rectangle vertically and find both side rectangle with minimum perimeter. Doing this will ensure that rectangles are disjoint. Repeat the process now by dividing the rectangle horizontally. We have already discussed the process to find the rectangles with sum equals to **K**. So, how exactly we are going to find the minimum perimeter rectangle within the range?\\n\\nTo find the minimum perimeter rectangle in the range, we will have to take four arrays, two of size **N** (for rows) and two of size **M** (for columns).\\n\\n### Code\\n\\n```cpp\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n#define INF 10000000\\n\\nint slidingWindow(vector<vector<int>>& roseGarden, int n, int m, int k){\\n    int st = -1,en = -1,perimeter = INF;\\n    vector<vector<int>> prefixL(n+1,vector<int>(m+1));\\n    vector<int> rowSt(n, INF), rowEn(n, INF), colSt(m, INF), colEn(m, INF);\\n    for(int i=0;i<=n;i++)   prefixL[i][0] = 0;\\n    for(int j=0;j<=m;j++)   prefixL[0][j] = 0;\\n    for(int i=1;i<=n;i++)\\n        for(int j=1;j<=m;j++)\\n            prefixL[i][j] = (roseGarden[i-1][j-1] + prefixL[i-1][j] + prefixL[i][j-1] - prefixL[i-1][j-1]);\\n    for(int i=0;i<n;i++){\\n        for(int j=i;j<n;j++){\\n            st = 0;en = 0;\\n            int cnt = prefixL[j+1][1] - prefixL[j+1][0] - prefixL[i][1] + prefixL[i][0];\\n            for(;en < m;){\\n                if(cnt > k){\\n                    if(st == en){   st++;en++;}\\n                    else            st++;\\n                }else if(cnt < k){\\n                    en++;\\n                }else{\\n                    while(st < en && ((prefixL[j+1][st+1] + prefixL[i][st]) == (prefixL[j+1][st] + prefixL[i][st+1])))\\n                        st++;\\n                    perimeter = 2*((j-i+1)+(en-st+1));\\n                    rowSt[j] = min(rowSt[j], perimeter);\\n                    rowEn[i] = min(rowEn[i], perimeter);\\n                    colSt[en] = min(colSt[en], perimeter);\\n                    colEn[st] = min(colEn[st], perimeter);\\n                    en++;\\n                }\\n                if(en >= m) break;\\n                cnt = (prefixL[j+1][en+1] + prefixL[i][st]) - (prefixL[j+1][st] + prefixL[i][en+1]);\\n            }\\n        }\\n    }\\n    for(int i=1;i<n;i++)\\n        rowSt[i] = min(rowSt[i], rowSt[i-1]);\\n    for(int i=n-2;i>=0;i--)\\n        rowEn[i] = min(rowEn[i], rowEn[i+1]);\\n    for(int j=1;j<m;j++)\\n        colSt[j] = min(colSt[j], colSt[j-1]);\\n    for(int j=m-2;j>=0;j--)\\n        colEn[j] = min(colEn[j], colEn[j+1]);\\n    int ans = INF;\\n    for(int i=1;i<n;i++)\\n        ans = min(ans, rowSt[i-1] + rowEn[i]);\\n    for(int j=1;j<m;j++)\\n        ans = min(ans, colSt[j-1] + colEn[j]);\\n    return ans;\\n}\\n\\nint main() {\\n    int l,w,n,k;\\n    cin >> l >> w\\n        >> n >> k;\\n    vector<vector<int>> roseGarden(l,vector<int>(w, 0));\\n    int x,y;\\n    while(n--){\\n        cin >> x >> y;\\n        x--;y--;\\n        roseGarden[x][y]++;\\n    }\\n    int ans = slidingWindow(roseGarden,l,w,k);\\n    if(ans == INF)  cout << \\"NO\\\\n\\";\\n    else            cout << ans;\\n    return 0;\\n}\\n```"},{"id":"ioitc-day-1-part-2","metadata":{"permalink":"/lcc/blog/ioitc-day-1-part-2","editUrl":"https://github.com/trayimurti/lcc/blog/2022-01-24-ioitc-day-1-part-2.md","source":"@site/blog/2022-01-24-ioitc-day-1-part-2.md","title":"IOITC Day-1 Part-2","description":"So, What if the numbers can also be negative?","date":"2022-01-24T00:00:00.000Z","formattedDate":"January 24, 2022","tags":[{"label":"ioitc","permalink":"/lcc/blog/tags/ioitc"},{"label":"ioi","permalink":"/lcc/blog/tags/ioi"},{"label":"sliding-window-algorithm","permalink":"/lcc/blog/tags/sliding-window-algorithm"},{"label":"day-1","permalink":"/lcc/blog/tags/day-1"},{"label":"part-2","permalink":"/lcc/blog/tags/part-2"}],"readingTime":3.49,"truncated":true,"authors":[{"name":"Trayi Murti","title":"IOI Training Camp Participant","url":"https://github.com/trayimurti","imageURL":"https://github.com/trayimurti.png","key":"trayimurti"}],"frontMatter":{"slug":"ioitc-day-1-part-2","title":"IOITC Day-1 Part-2","authors":"trayimurti","tags":["ioitc","ioi","sliding-window-algorithm","day-1","part-2"]},"prevItem":{"title":"IOITC Day-1 Part-3","permalink":"/lcc/blog/ioitc-day-1-part-3"},"nextItem":{"title":"IOITC Day-1 Part-1","permalink":"/lcc/blog/ioitc-day-1-part-1"}},"content":"So, What if the numbers can also be negative? \\n\\nWe can\'t use sliding window algorithm then. First we will compute prefix sum and then sort it with their respective index (sort them as **{prefixL[i],i}**). Then we will apply binary search on it for every index **i** to look for an element whose index **j** is greater than index **i** and whose value is equal to **prefixL[i] + K**. This will take $\\\\cal{O}(n \\\\cdot \\\\log(n))$ time.\\n\\n\x3c!--truncate--\x3e\\n\\n## Problem\\n\\nGiven a list of integers **L = [A<sub>1</sub>, A<sub>2</sub>, A<sub>3</sub>, \u2026, A<sub>N</sub>]**. Where **A<sub>i</sub> \u2208 I**, **0 \u2264 i \u2264 N**. You have to find the shortest contiguous segment in the list which adds up to a given integer **K**. If there are more than one such segments, print one of them.\\n\\nFor example, \\nIf  **L = [2, 1, 10, 1, 3, -4, -2, 20, 5, 5, 5, 1, 1]** and **K = 17**, the answer would be **{4, 7}**.\\n\\n## Code\\n\\n```cpp\\nstruct keycompare {\\n   bool operator()(const pair<int, int>& v, const int& k) {\\n      return (v.first < k);\\n   }\\n   bool operator()(const int& k, const pair<int, int>& v) {\\n      return (k < v.first);\\n   }\\n};\\n\\npair<int,int> prefixSum(vector<int> l, int n, int k){\\n    int st,en,len = INF;\\n    vector<pair<int,int>> prefixL(n+1);\\n    prefixL[0].first = 0;\\n    prefixL[0].second = 0;\\n    for(int i=0;i<n;i++){\\n        prefixL[i+1].first = prefixL[i].first + l[i];\\n        prefixL[i+1].second = i+1;\\n    }\\n    for(int i=0;i<n;i++){\\n        int x = lower_bound(prefixL.begin(), prefixL.end(), prefixL[i].first + k, keycompare()) - prefixL.begin();\\n        if(x <= n && prefixL[x].first == prefixL[i].first + k && x-i < len && prefixL[x].second > prefixL[i].second){\\n            len = x-i;\\n            en = x-1;\\n            st = i;\\n        }\\n    }\\n    return {st,en};\\n}\\n```\\n\\nLet\'s make the problem even more interesting.\\n\\n## Problem\\n\\nGiven a list of integers **L = [A<sub>1</sub>, A<sub>2</sub>, A<sub>3</sub>, \u2026, A<sub>N</sub>]**. Where **A<sub>i</sub> \u2265 0**, **0 \u2264 i \u2264 N**. You have to find a pair of the shortest disjoint contiguous segment in the list each adding up to a given integer **K** and sum of size of segment is minimum. If there are more than one such pair of segments, print one of such pair.\\n\\nFor example,\\nIf  **L = [2, 1, 3, 1, 4, 4, 1, 8, 1, 7]** and **K = 9**, the answer would be **{{3, 5}, {6, 7}}**.\\n\\n## Solution\\n\\nNote that pairs of segments have to be disjoint. So, we can\'t simply say that the segments with least size will be the answer. Even in the given example **{6, 7}** and **{7, 8}** are two least size segments, but they have a common index which doesn\'t follow the condition of being disjoint. Then, what should we do?\\n\\nLet us take an index **i**, for each i we will find the least size segment in range **[0, i]** and **(i, N)**. Doing this will ensure that the segments are disjoint. As far as searching segment in the ranges concerned, we can find them by applying sliding window algorithm from both the sides.\\n\\n### Code\\n```cpp\\nvoid slidingWindow(vector<int> l, int n, int k){\\n    int st = -1,en = -1,len = INF;\\n    vector<pair<int,int>> s1(n,{-1,-1}),s2(n,{-1,-1});\\n    int sum = l[0];\\n    // sliding window from front\\n    for(int i=0,j=0;i<n && j<n;){\\n        s1[j] = {st, en};\\n        if(sum < k){\\n            j++;\\n            if(j < n)   sum += l[j];\\n            else        break;\\n            \\n        }else if(sum > k){\\n            sum -= l[i];\\n            if(i < j)   i++;\\n            else{\\n                i++;\\n                j++;\\n                sum += l[j];\\n            }\\n        }else{\\n            if(j-i+1 < len){\\n                st = i;\\n                en = j;\\n                len = j-i+1;\\n            }\\n            j++;\\n            s1[j] = {st, en};\\n            if(j < n)   sum += l[j];\\n            else        break;\\n        }\\n    }\\n    sum = l[n-1];\\n    len = INF;\\n    st = -1;en = -1;\\n    // sliding window from end\\n    for(int i=n-1,j=n-1;i>=0 && j>=0;){\\n        s2[i] = {st, en};\\n        if(sum < k){\\n            i--;\\n            if(i >= 0)   sum += l[i];\\n            else        break;\\n            \\n        }else if(sum > k){\\n            sum -= l[j];\\n            if(i < j)   j--;\\n            else{\\n                i--;\\n                j--;\\n                sum += l[i];\\n            }\\n        }else{\\n            if(j-i+1 < len){\\n                st = i;\\n                en = j;\\n                len = j-i+1;\\n            }\\n            s2[i] = {st, en};\\n            i--;\\n            if(i >= 0)   sum += l[i];\\n            else        break;\\n        }\\n    }\\n    len = INF;\\n    for(int i=0;i<n-1;i++){\\n        if(s1[i].first != -1 && s2[i+1].first != -1){\\n            if(((s1[i].second + s2[i+1].second + 2) - (s1[i].first + s2[i+1].first)) < len){\\n                ans[0] = s1[i];\\n                ans[1] = s2[i+1];\\n            }\\n        }\\n    }\\n}\\n```"},{"id":"ioitc-day-1-part-1","metadata":{"permalink":"/lcc/blog/ioitc-day-1-part-1","editUrl":"https://github.com/trayimurti/lcc/blog/2022-01-23-ioitc-day-1-part-1.md","source":"@site/blog/2022-01-23-ioitc-day-1-part-1.md","title":"IOITC Day-1 Part-1","description":"Let us start with a problem","date":"2022-01-23T00:00:00.000Z","formattedDate":"January 23, 2022","tags":[{"label":"ioitc","permalink":"/lcc/blog/tags/ioitc"},{"label":"ioi","permalink":"/lcc/blog/tags/ioi"},{"label":"sliding-window-algorithm","permalink":"/lcc/blog/tags/sliding-window-algorithm"},{"label":"day-1","permalink":"/lcc/blog/tags/day-1"},{"label":"part-1","permalink":"/lcc/blog/tags/part-1"}],"readingTime":2.65,"truncated":true,"authors":[{"name":"Trayi Murti","title":"IOI Training Camp Participant","url":"https://github.com/trayimurti","imageURL":"https://github.com/trayimurti.png","key":"trayimurti"}],"frontMatter":{"slug":"ioitc-day-1-part-1","title":"IOITC Day-1 Part-1","authors":"trayimurti","tags":["ioitc","ioi","sliding-window-algorithm","day-1","part-1"]},"prevItem":{"title":"IOITC Day-1 Part-2","permalink":"/lcc/blog/ioitc-day-1-part-2"},"nextItem":{"title":"Welcome","permalink":"/lcc/blog/welcome"}},"content":"Let us start with a problem\\n\\n## Problem\\n\\nGiven a list of integers **L = [A<sub>1</sub>, A<sub>2</sub>, A<sub>3</sub>, \u2026, A<sub>N</sub>]**. Where **A<sub>i</sub> \u2265 0**, **0 \u2264 i \u2264 N**. You have to find the shortest contiguous segment in the list which adds up to a given integer **K**. If there are more than one such segment, print one of them.\\n\\n\x3c!--truncate--\x3e\\n\\nFor example, \\nIf  **L = [2, 1, 3, 1, 4, 4, 1, 8, 1, 7]** and **K = 9**, the answer would be **{6, 7}**.\\n\\n## By Naive Approach\\n\\nFind every possible segment and sum up elements present in it. This will have $\\\\cal{O}(n^2)$ time complexity.\\n\\n### Code\\n\\n```cpp\\npair<int,int> naive(vector<int> l, int n, int k){\\n\\tint st,en,len = INF;\\n\\tfor(int i=0;i<n;i++){\\n\\t\\tint sum = 0;\\n\\t\\tfor(int j=i;j<n;j++){\\n\\t\\t\\tsum += l[j];\\n\\t\\t\\tif(sum == k && j-i+1 < len){\\n\\t\\t\\t\\tlen = j-i+1;\\n\\t\\t\\t\\tst = i;\\n\\t\\t\\t\\ten = j;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif(sum > k){\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn {st,en};\\n}\\n```\\n\\nCan we do better?\\n\\n## By Prefix Sum\\n\\nCompute the prefix sum of array **L** into another array **prefixL** (make sure to add an extra element \\"0\\" before the list) , for every index **i** in **prefixL**, search if an element exists with value **prefixL[i] + K** and return the indices of the segment with minimum length. We can search for elements with the help of Binary Search, which will take $\\\\cal{O}(\\\\log(n))$ time. So, overall it will have $\\\\cal{O}(n \\\\cdot \\\\log(n))$ time complexity.\\n\\n### Code\\n\\n```cpp\\npair<int,int> prefixSum(vector<int> l, int n, int k){\\n    int st,en,len = INF;\\n    vector<int> prefixL(n+1);\\n    prefixL[0] = 0;\\n    for(int i=0;i<n;i++)\\n        prefixL[i+1] = prefixL[i] + l[i];\\n    for(int i=0;i<n;i++){\\n        int x = lower_bound(prefixL.begin(), prefixL.end(), prefixL[i] + k) - prefixL.begin();\\n        if(x <= n && prefixL[x] == prefixL[i] + k && x-i < len){\\n            len = x-i;\\n            en = x-1;\\n            st = i;\\n        }\\n    }\\n    return {st,en};\\n}\\n```\\n\\nCan we still do better?\\n\\n## By Sliding Window Algorithm\\n\\nAs the name suggests, we will use two vectors **i** and **j** to point at starting and ending elements of the segment respectively. If the current sum of the segment is less than **K** then increase the index **j** and include the element in the sum. If the current sum of the segment is greater than K then increase the index **i** and exclude the from the sum. When the current segment sum is equal to **K**, store the indices if the segment length is less than the previous one. As the array is iterated once, So, time complexity will be $\\\\cal{O}(n)$. \\n\\n### Code\\n\\n```cpp\\npair<int,int> slidingWindow(vector<int> l, int n, int k){\\n    int st,en,len = INF;\\n    int sum = l[0];\\n    for(int i=0,j=0;i<n && j<n;){\\n        if(sum < k){\\n            j++;\\n            if(j < n)   sum += l[j];\\n            else        break;\\n        }else if(sum > k){\\n            sum -= l[i];\\n            if(i < j)   i++;\\n            else{\\n                j++;\\n                sum += l[j];\\n            }\\n        }else{\\n            if(j-i+1 < len){\\n                st = i;\\n                en = j;\\n                len = j-i+1;\\n            }\\n            j++;\\n            if(j < n)   sum += l[j];\\n            else        break;\\n        }\\n    }\\n    return {st,en};\\n}\\n```\\n\\n:::note Note\\nSome conditions were added in the code to ensure that **i \u2264 j** and **j < n**.\\n:::\\n\\nWhat if the numbers can also be negative?"},{"id":"welcome","metadata":{"permalink":"/lcc/blog/welcome","editUrl":"https://github.com/trayimurti/lcc/blog/2022-01-23-welcome/index.md","source":"@site/blog/2022-01-23-welcome/index.md","title":"Welcome","description":"This blog contains things which are different from straight data structures and algorithms, but useful for others.","date":"2022-01-23T00:00:00.000Z","formattedDate":"January 23, 2022","tags":[{"label":"lcc","permalink":"/lcc/blog/tags/lcc"},{"label":"welcome","permalink":"/lcc/blog/tags/welcome"},{"label":"blog","permalink":"/lcc/blog/tags/blog"}],"readingTime":0.165,"truncated":false,"authors":[{"name":"Trayi Murti","title":"IOI Training Camp Participant","url":"https://github.com/trayimurti","imageURL":"https://github.com/trayimurti.png","key":"trayimurti"}],"frontMatter":{"slug":"welcome","title":"Welcome","authors":"trayimurti","tags":["lcc","welcome","blog"],"sidebar_position":1},"prevItem":{"title":"IOITC Day-1 Part-1","permalink":"/lcc/blog/ioitc-day-1-part-1"}},"content":"This blog contains things which are different from straight data structures and algorithms, but useful for others.\\n\\nLCC (Learn . Code . Contribute) is a website that helps coders to achieve their goal."}]}')}}]);