"use strict";(self.webpackChunklcc=self.webpackChunklcc||[]).push([[53],{1109:function(a){a.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Data Structures and Algorithms","href":"/lcc/docs/intro","docId":"intro"},{"type":"category","label":"Graph Algorithms","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction to Graph","href":"/lcc/docs/graph-algorithms/what-is-a-graph","docId":"graph-algorithms/what-is-a-graph"},{"type":"category","label":"Basics of Graph","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Graph Terminology","href":"/lcc/docs/graph-algorithms/graph-basics/graph-terminology","docId":"graph-algorithms/graph-basics/graph-terminology"},{"type":"link","label":"Graph Representation","href":"/lcc/docs/graph-algorithms/graph-basics/graph-representation","docId":"graph-algorithms/graph-basics/graph-representation"}]},{"type":"category","label":"Graph Traversal","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Depth-First Search (DFS)","href":"/lcc/docs/graph-algorithms/graph-traversal/dfs","docId":"graph-algorithms/graph-traversal/dfs"},{"type":"link","label":"Breadth-First Search (BFS)","href":"/lcc/docs/graph-algorithms/graph-traversal/bfs","docId":"graph-algorithms/graph-traversal/bfs"},{"type":"link","label":"Applications","href":"/lcc/docs/graph-algorithms/graph-traversal/applications","docId":"graph-algorithms/graph-traversal/applications"}]},{"type":"category","label":"Shortest Paths","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Basics","href":"/lcc/docs/graph-algorithms/shortest-paths/basics","docId":"graph-algorithms/shortest-paths/basics"},{"type":"link","label":"Bellman-Ford Algorithm","href":"/lcc/docs/graph-algorithms/shortest-paths/bellman-ford","docId":"graph-algorithms/shortest-paths/bellman-ford"},{"type":"link","label":"Shortest Path Faster Algorithm (SPFA)","href":"/lcc/docs/graph-algorithms/shortest-paths/spfa","docId":"graph-algorithms/shortest-paths/spfa"},{"type":"link","label":"Dijkstra\'s Algorithm","href":"/lcc/docs/graph-algorithms/shortest-paths/dijkstra","docId":"graph-algorithms/shortest-paths/dijkstra"},{"type":"link","label":"Floyd-Warshall Algorithm","href":"/lcc/docs/graph-algorithms/shortest-paths/floyd-warshall","docId":"graph-algorithms/shortest-paths/floyd-warshall"}]},{"type":"category","label":"Directed Acyclic Graphs","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Topological Sorting","href":"/lcc/docs/graph-algorithms/directed-acyclic-graphs/topological-sort","docId":"graph-algorithms/directed-acyclic-graphs/topological-sort"},{"type":"link","label":"Dynamic programming","href":"/lcc/docs/graph-algorithms/directed-acyclic-graphs/dynamic-programming","docId":"graph-algorithms/directed-acyclic-graphs/dynamic-programming"}]},{"type":"category","label":"Successor Graphs","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/lcc/docs/graph-algorithms/successor-graphs/intro","docId":"graph-algorithms/successor-graphs/intro"},{"type":"link","label":"Finding Successor","href":"/lcc/docs/graph-algorithms/successor-graphs/finding-successors","docId":"graph-algorithms/successor-graphs/finding-successors"},{"type":"link","label":"Cycle Detection","href":"/lcc/docs/graph-algorithms/successor-graphs/cycle-detection","docId":"graph-algorithms/successor-graphs/cycle-detection"}]},{"type":"category","label":"Minimum Spanning Trees","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Introduction","href":"/lcc/docs/graph-algorithms/mst/intro","docId":"graph-algorithms/mst/intro"},{"type":"link","label":"Kruskal\'s Algorithm","href":"/lcc/docs/graph-algorithms/mst/kruskal","docId":"graph-algorithms/mst/kruskal"},{"type":"link","label":"ufs","href":"/lcc/docs/graph-algorithms/mst/ufs","docId":"graph-algorithms/mst/ufs"}]}]}]},"docs":{"graph-algorithms/directed-acyclic-graphs/dynamic-programming":{"id":"graph-algorithms/directed-acyclic-graphs/dynamic-programming","title":"Dynamic programming","description":"Using dynamic programming, we can efficiently answer many questions regarding paths in directed acyclic graphs. Examples of such questions are:","sidebar":"tutorialSidebar"},"graph-algorithms/directed-acyclic-graphs/topological-sort":{"id":"graph-algorithms/directed-acyclic-graphs/topological-sort","title":"Topological Sorting","description":"| A graph and topological sort |","sidebar":"tutorialSidebar"},"graph-algorithms/graph-basics/graph-representation":{"id":"graph-algorithms/graph-basics/graph-representation","title":"Graph Representation","description":"There are three classical ways to represent a graph. The choice of a data structure depends on the size of the graph and the way the algorithm processes it.","sidebar":"tutorialSidebar"},"graph-algorithms/graph-basics/graph-terminology":{"id":"graph-algorithms/graph-basics/graph-terminology","title":"Graph Terminology","description":"In this course we will use variable n as number of nodes and variable m as number of edges.","sidebar":"tutorialSidebar"},"graph-algorithms/graph-traversal/applications":{"id":"graph-algorithms/graph-traversal/applications","title":"Applications","description":"In the applications described below we will assume that the graph is undirected.","sidebar":"tutorialSidebar"},"graph-algorithms/graph-traversal/bfs":{"id":"graph-algorithms/graph-traversal/bfs","title":"Breadth-First Search (BFS)","description":"Breadth-first search (BFS) visits the nodes of a graph in increasing order of their distance from the starting node. Thus, we can calculate the distance from the starting node to all other nodes using breadth-first search. However, breadth-first search is more difficult to implement than depth-first search.","sidebar":"tutorialSidebar"},"graph-algorithms/graph-traversal/dfs":{"id":"graph-algorithms/graph-traversal/dfs","title":"Depth-First Search (DFS)","description":"Depth-first search (DFS) is a straightforward graph traversal technique. The algorithm begins at a starting node and proceeds to all other nodes that are reachable from the starting node using the edges of the graph.","sidebar":"tutorialSidebar"},"graph-algorithms/mst/intro":{"id":"graph-algorithms/mst/intro","title":"Introduction","description":"A spanning tree contains all nodes of a graph and some of its edges so that there is a path between any two nodes. Like trees in general, spanning trees are connected and acyclic. The weight of a spanning tree is the sum of its edge weights. For example, Fig. 35 shows a graph and one of its spanning tree. The weight of this spanning tree is $3 + 5 + 9 + 3 + 2 = 22.$","sidebar":"tutorialSidebar"},"graph-algorithms/mst/kruskal":{"id":"graph-algorithms/mst/kruskal","title":"Kruskal\'s Algorithm","description":"Kruskal\u2019s algorithm builds a minimum spanning tree by greedily adding edges to the graph. The initial spanning tree only contains the nodes of the graph and does not contain any edges. Then the algorithm goes through the edges ordered by their weights and always adds an edge to the graph if it does not create a cycle.","sidebar":"tutorialSidebar"},"graph-algorithms/mst/ufs":{"id":"graph-algorithms/mst/ufs","title":"ufs","description":"ufs.md","sidebar":"tutorialSidebar"},"graph-algorithms/shortest-paths/basics":{"id":"graph-algorithms/shortest-paths/basics","title":"Basics","description":"Finding a shortest path between two nodes of a graph is an important problem that has many practical applications. For example, a natural problem related to a road network is to calculate the shortest possible length of a route between two cities, given the lengths of the roads.","sidebar":"tutorialSidebar"},"graph-algorithms/shortest-paths/bellman-ford":{"id":"graph-algorithms/shortest-paths/bellman-ford","title":"Bellman-Ford Algorithm","description":"The Bellman\u2013Ford algorithm finds shortest paths from a starting node to all nodes of the graph. The algorithm can process all kinds of graphs, provided that the graph does not contain a cycle with negative length. If the graph contains a negative cycle, the algorithm can detect this.","sidebar":"tutorialSidebar"},"graph-algorithms/shortest-paths/dijkstra":{"id":"graph-algorithms/shortest-paths/dijkstra","title":"Dijkstra\'s Algorithm","description":"Dijkstra\u2019s algorithm finds shortest paths from the starting node to all nodes of the graph, like the Bellman\u2013Ford algorithm. The benefit of Dijkstra\u2019s algorithm is that it is more efficient and can be used for processing large graphs. However, the algorithm requires that there are no negative weight edges in the graph.","sidebar":"tutorialSidebar"},"graph-algorithms/shortest-paths/floyd-warshall":{"id":"graph-algorithms/shortest-paths/floyd-warshall","title":"Floyd-Warshall Algorithm","description":"The Floyd\u2013Warshall algorithm provides an alternative way to approach the problem of finding shortest paths. It finds shortest paths between all node pairs of the graph in a single run.","sidebar":"tutorialSidebar"},"graph-algorithms/shortest-paths/spfa":{"id":"graph-algorithms/shortest-paths/spfa","title":"Shortest Path Faster Algorithm (SPFA)","description":"Algorithm","sidebar":"tutorialSidebar"},"graph-algorithms/successor-graphs/cycle-detection":{"id":"graph-algorithms/successor-graphs/cycle-detection","title":"Cycle Detection","description":"Consider a successor graph that only contains a path that ends in a cycle. We may ask the following questions: if we begin our walk at the starting node, what is the first node in the cycle and how many nodes does the cycle contain? For example, in Fig. 34, we begin our walk at node 1, the first node that belongs to the cycle is node 4, and the cycle consists of three nodes (4, 5, and 6).","sidebar":"tutorialSidebar"},"graph-algorithms/successor-graphs/finding-successors":{"id":"graph-algorithms/successor-graphs/finding-successors","title":"Finding Successor","description":"Since each node of a successor graph has a unique successor, we can also define a function succ(x, k) that gives the node that we will reach if we begin at node x and walk k steps forward. For example, in our example graph succ(4, 6) = 2, because we will reach node 2 by walking 6 steps from node 4 (Fig. 33).","sidebar":"tutorialSidebar"},"graph-algorithms/successor-graphs/intro":{"id":"graph-algorithms/successor-graphs/intro","title":"Introduction","description":"Successor Graphs","sidebar":"tutorialSidebar"},"graph-algorithms/what-is-a-graph":{"id":"graph-algorithms/what-is-a-graph","title":"Introduction to Graph","description":"What is a Graph?","sidebar":"tutorialSidebar"},"intro":{"id":"intro","title":"Data Structures and Algorithms","description":"Data Structure","sidebar":"tutorialSidebar"}}}')}}]);