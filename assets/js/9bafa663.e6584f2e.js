"use strict";(self.webpackChunklcc=self.webpackChunklcc||[]).push([[4515],{3905:function(e,t,a){a.d(t,{Zo:function(){return l},kt:function(){return d}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=n.createContext({}),p=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},l=function(e){var t=p(e.components);return n.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),h=p(a),d=r,g=h["".concat(c,".").concat(d)]||h[d]||m[d]||i;return a?n.createElement(g,s(s({ref:t},l),{},{components:a})):n.createElement(g,s({ref:t},l))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=h;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var p=2;p<i;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},4486:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return o},contentTitle:function(){return c},metadata:function(){return p},toc:function(){return l},default:function(){return h}});var n=a(7462),r=a(3366),i=(a(7294),a(3905)),s=["components"],o={sidebar_position:3,tags:["graph","graph-traversal","applications","connectivity-check","cycle-detection","\tbipartiteness-check"]},c="Applications",p={unversionedId:"graph-algorithms/graph-traversal/applications",id:"graph-algorithms/graph-traversal/applications",title:"Applications",description:"In the applications described below we will assume that the graph is undirected.",source:"@site/docs/graph-algorithms/graph-traversal/applications.md",sourceDirName:"graph-algorithms/graph-traversal",slug:"/graph-algorithms/graph-traversal/applications",permalink:"/lcc/docs/graph-algorithms/graph-traversal/applications",editUrl:"https://github.com/trayimurti/lcc/tree/main/docs/graph-algorithms/graph-traversal/applications.md",tags:[{label:"graph",permalink:"/lcc/docs/tags/graph"},{label:"graph-traversal",permalink:"/lcc/docs/tags/graph-traversal"},{label:"applications",permalink:"/lcc/docs/tags/applications"},{label:"connectivity-check",permalink:"/lcc/docs/tags/connectivity-check"},{label:"cycle-detection",permalink:"/lcc/docs/tags/cycle-detection"},{label:"\tbipartiteness-check",permalink:"/lcc/docs/tags/bipartiteness-check"}],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,tags:["graph","graph-traversal","applications","connectivity-check","cycle-detection","\tbipartiteness-check"]},sidebar:"tutorialSidebar",previous:{title:"Breadth-First Search (BFS)",permalink:"/lcc/docs/graph-algorithms/graph-traversal/bfs"}},l=[{value:"Connectivity Check",id:"connectivity-check",children:[],level:2},{value:"Cycle Detection",id:"cycle-detection",children:[],level:2},{value:"Bipartiteness Check",id:"bipartiteness-check",children:[],level:2}],m={toc:l};function h(e){var t=e.components,o=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,n.Z)({},m,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"applications"},"Applications"),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"NOTE")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"In the applications described below we will assume that the graph is undirected."))),(0,i.kt)("h2",{id:"connectivity-check"},"Connectivity Check"),(0,i.kt)("p",null,"A graph is connected if there is a path between any two nodes of the graph. Thus, we can check if a graph is connected by starting at an arbitrary node and finding out if we can reach all other nodes."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},(0,i.kt)("img",{alt:"Checking the connectivity of a graph",src:a(3761).Z,width:"281",height:"165"})))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("strong",{parentName:"td"},"Fig. 15:")," Checking the connectivity of a graph")))),(0,i.kt)("p",null,"For example, in Fig. 15, since a depth-first search from node 1 does not visit all  the nodes, we can conclude that the graph is not connected. In a similar way, we can  also find all connected components of a graph by iterating through the nodes and  always starting a new depth-first search if the current node does not belong to any component yet."),(0,i.kt)("h2",{id:"cycle-detection"},"Cycle Detection"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},(0,i.kt)("img",{alt:"Finding a cycle in a graph",src:a(6258).Z,width:"274",height:"170"})))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("strong",{parentName:"td"},"Fig. 16:")," Finding a cycle in a graph")))),(0,i.kt)("p",null,"A graph contains a cycle if during a graph traversal, we find a node whose neighbor (other than the previous node in the current path) has already been visited. For example, in Fig. 16, a depth-first search from node 1 reveals that the graph contains a cycle. After moving from node 2 to node 5 we notice that the neighbor 3 of node 5 has already been visited. Thus, the graph contains a cycle that goes through node 3, for example, ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mn",{parentName:"mrow"},"3"),(0,i.kt)("mo",{parentName:"mrow"},"\u2192"),(0,i.kt)("mn",{parentName:"mrow"},"2"),(0,i.kt)("mo",{parentName:"mrow"},"\u2192"),(0,i.kt)("mn",{parentName:"mrow"},"5"),(0,i.kt)("mo",{parentName:"mrow"},"\u2192"),(0,i.kt)("mn",{parentName:"mrow"},"3")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"3 \\to 2 \\to 5 \\to 3")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"3"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.kt)("span",{parentName:"span",className:"mrel"},"\u2192"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"2"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.kt)("span",{parentName:"span",className:"mrel"},"\u2192"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"5"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.kt)("span",{parentName:"span",className:"mrel"},"\u2192"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"3"))))),"."),(0,i.kt)("p",null,"Another way to determine if a graph contains a cycle is to simply calculate the number of nodes and edges in every component. If a component contains ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," nodes and no cycle, it must contain exactly ",(0,i.kt)("inlineCode",{parentName:"p"},"c \u2212 1")," edges (so it has to be a tree). If there are ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," or more edges, the component surely contains a cycle."),(0,i.kt)("h2",{id:"bipartiteness-check"},"Bipartiteness Check"),(0,i.kt)("p",null,"A graph is bipartite if its nodes can be colored using two colors so that there are no adjacent nodes with the same color. It is surprisingly easy to check if a graph is bipartite using graph traversal algorithms."),(0,i.kt)("p",null,"The idea is to pick two colors ",(0,i.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Y"),", color the starting node ",(0,i.kt)("inlineCode",{parentName:"p"},"X"),", all its neighbors ",(0,i.kt)("inlineCode",{parentName:"p"},"Y"),", all their neighbors ",(0,i.kt)("inlineCode",{parentName:"p"},"X"),", and so on. If at some point of the search we notice that two adjacent nodes have the same color, this means that the graph is not bipartite. Otherwise the graph is bipartite and one coloring has been found."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},(0,i.kt)("img",{alt:"A conflict while checking bipartiteness",src:a(3804).Z,width:"274",height:"164"})))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("strong",{parentName:"td"},"Fig. 17:")," A conflict while checking bipartiteness")))),(0,i.kt)("p",null,"For example, in Fig. 17, a depth-first search from node 1 shows that the graph is not bipartite, because we notice that both nodes 2 and 5 should have the same color, while they are adjacent nodes in the graph. "),(0,i.kt)("p",null,"This algorithm always works, because when there are only two colors available, the color of the starting node in a component determines the colors of all other nodes in the component. It does not make any difference what the colors are."),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"NOTE")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"In the general case it is difficult to find out if the nodes in a graph can be colored using ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," colors so that no adjacent nodes have the same color. The problem is NP-hard already for ",(0,i.kt)("inlineCode",{parentName:"p"},"k = 3"),"."))))}h.isMDXComponent=!0},3761:function(e,t,a){t.Z=a.p+"assets/images/15-66a1514d3a0512bff7caa224e64fcc92.png"},6258:function(e,t,a){t.Z=a.p+"assets/images/16-baaea5f628034e0d2634460828a8bf2a.png"},3804:function(e,t,a){t.Z=a.p+"assets/images/17-e3542f00833e0c28b032661682b6425f.png"}}]);