"use strict";(self.webpackChunklcc=self.webpackChunklcc||[]).push([[1372],{3905:function(e,n,t){t.d(n,{Zo:function(){return s},kt:function(){return m}});var i=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=i.createContext({}),d=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},s=function(e){var n=d(e.components);return i.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},p=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=d(t),m=r,f=p["".concat(l,".").concat(m)]||p[m]||u[m]||o;return t?i.createElement(f,a(a({ref:n},s),{},{components:t})):i.createElement(f,a({ref:n},s))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,a=new Array(o);a[0]=p;var c={};for(var l in n)hasOwnProperty.call(n,l)&&(c[l]=n[l]);c.originalType=e,c.mdxType="string"==typeof e?e:r,a[1]=c;for(var d=2;d<o;d++)a[d]=t[d];return i.createElement.apply(null,a)}return i.createElement.apply(null,t)}p.displayName="MDXCreateElement"},8422:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return c},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return s},default:function(){return p}});var i=t(7462),r=t(3366),o=(t(7294),t(3905)),a=["components"],c={sidebar_position:4,tags:["graph","inoi","dfs","connected-graph","2013"]},l="Sequence Land, INOI 2013",d={unversionedId:"inoi/inoi1302",id:"inoi/inoi1302",title:"Sequence Land, INOI 2013",description:"Problem Description",source:"@site/code/inoi/inoi1302.md",sourceDirName:"inoi",slug:"/inoi/inoi1302",permalink:"/lcc/code/inoi/inoi1302",editUrl:"https://github.com/trayimurti/lcc/tree/main/code/inoi/inoi1302.md",tags:[{label:"graph",permalink:"/lcc/code/tags/graph"},{label:"inoi",permalink:"/lcc/code/tags/inoi"},{label:"dfs",permalink:"/lcc/code/tags/dfs"},{label:"connected-graph",permalink:"/lcc/code/tags/connected-graph"},{label:"2013",permalink:"/lcc/code/tags/2013"}],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,tags:["graph","inoi","dfs","connected-graph","2013"]},sidebar:"tutorialSidebar",previous:{title:"Calvins Game, INOI 2013",permalink:"/lcc/code/inoi/inoi1301"}},s=[{value:"Problem Description",id:"problem-description",children:[],level:2},{value:"Prerequisites",id:"prerequisites",children:[],level:2},{value:"Solution",id:"solution",children:[],level:2},{value:"Code",id:"code",children:[],level:2}],u={toc:s};function p(e){var n=e.components,t=(0,r.Z)(e,a);return(0,o.kt)("wrapper",(0,i.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"sequence-land-inoi-2013"},"Sequence Land, INOI 2013"),(0,o.kt)("h2",{id:"problem-description"},"Problem Description"),(0,o.kt)("p",null,"Question : ",(0,o.kt)("a",{parentName:"p",href:"https://www.codechef.com/INOIPRAC/problems/INOI1302"},"Sequence Land, INOI 2013")," "),(0,o.kt)("p",null,"Submit Code : ",(0,o.kt)("a",{parentName:"p",href:"https://www.codechef.com/INOIPRAC/submit/INOI1302"},"Codechef")),(0,o.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://trayimurti.github.io/lcc/docs/graph-algorithms/graph-traversal/dfs"},"Depth-First Search"),", ",(0,o.kt)("a",{parentName:"p",href:"https://trayimurti.github.io/lcc/docs/graph-algorithms/graph-basics/graph-terminology#connected-graph"},"Connected Graph")),(0,o.kt)("h2",{id:"solution"},"Solution"),(0,o.kt)("p",null,"It's clear that extended family forms a tree. The Presindent will be root node and his relatives will be its children nodes and relatives of relatives will be children nodes of them and so on."),(0,o.kt)("p",null,"To get our answer we will do the followings:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"we will connect node ",(0,o.kt)("inlineCode",{parentName:"li"},"a")," with node ",(0,o.kt)("inlineCode",{parentName:"li"},"b")," if number of common ids will be greater than or equal to ",(0,o.kt)("inlineCode",{parentName:"li"},"k"),"."),(0,o.kt)("li",{parentName:"ol"},"Now, we just have to find number of nodes connected to node ",(0,o.kt)("inlineCode",{parentName:"li"},"0")," (The President). We will use DFS to traverse all element connected with node ",(0,o.kt)("inlineCode",{parentName:"li"},"0"),".")),(0,o.kt)("h2",{id:"code"},"Code"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid dfs(vector<int>* adj, vector<int>& visited, int idx){\n    visited[idx] = 1;\n    for(int u : adj[idx])\n        if(!visited[u])\n            dfs(adj, visited, u);\n}\n\nint main(){\n    int n, k;\n    cin >> n >> k;\n    vector<int> sequenceId[n];\n    int m, x;\n    \n    for(int i=0;i<n;i++){\n        cin >> m;\n        for(int j=0;j<m;j++){\n            cin >> x;\n            sequenceId[i].push_back(x);\n        }\n    }\n\n    vector<int> adj[n];\n    for(int i=0;i<n;i++){\n        map<int, int> id;\n        for(int j=0;j<(int)sequenceId[i].size();j++)\n            id[sequenceId[i][j]] = 1;\n        for(int j=i+1;j<n;j++){\n            int numCommonElement = 0;\n            for(int k=0;k<(int)sequenceId[j].size();k++)\n                if(id.count(sequenceId[j][k]))\n                    numCommonElement++;\n            if(numCommonElement >= k){\n                adj[i].push_back(j);\n                adj[j].push_back(i);\n            }\n        }\n    }\n\n    vector<int> visited(n, 0);\n    dfs(adj, visited, 0);\n\n    int extendedFamily = 0;\n    for(int i=0;i<n;i++)\n        if(visited[i])\n            extendedFamily++;\n    cout << extendedFamily;\n    return 0;\n}\n")))}p.isMDXComponent=!0}}]);